
## 多线程
#### 1.并行和并发有什么区别？
* 并行是指两个或者多个事件在同一时刻发生
* 并发是指两个或多个事件在同一时间间隔发生
* 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件
* 在一台处理器上“同时”处理多个任务是并行，在多台处理器上同时处理多个任务。如hadoop分布式集群

#### 2.ThreadLocal是什么？
* ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构
* ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰
* 在高并发场景下，可以实现无状态的调用，适用于各个线程不共享变量值的操作
* ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用

#### 3.Lock接口拥有synchronized所不具备的哪些特性?
* 与Synchronized不同，获取到锁的线程能够相应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放
* 超时获取锁，以及可以尝试非阻塞地获取锁(调用后可立即返回锁是否获取成功)
* Lock是一个接口，它需要程序员自己定义了锁获取和释放的基本操作

#### 4.线程和进程的区别？
- 进程是资源分配最小单位，线程是程序执行的最小单位
- 线程是进程的一个执行单元。线程也被称为轻量级进程。
- 线程执行开销小，但是不利于资源的管理和保护。对资源的管理和保护要求高，不限制开销和效率时，使用多进程。
- 进程执行开销大，但是能够很好的进行资源管理和保护。要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

#### 5.守护线程是什么？
- 守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。

#### 6.创建线程有哪几种方式？
- 继承Thread类和实现Runnable接口，以及线程池技术
- 通过Callable接口并实现call()方法，该call()方法将作为线程执行体，并且有返回值


#### 7.说一下 runnable 和 callable 有什么区别？
- 相同点：两者都是接口。都可以用来创建多线程。都需要调用Thread.start()启动线程
- 不同点：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果。
- Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；
- Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞

#### 8.说一下 synchronized 底层实现原理？
- synchronized加在普通方法上，锁的当前对象的实例。也叫对象锁
- synchronized加在static方法上.锁的事当前类的class对象。也就是当前类的字节码文件对象，当类加载进内存，就会产生字节码文件对象
- 同步方法块，锁是括号里面的对象。同步代码块是使用monitorenter和monitorexit指令实现的.JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；
- 同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现
- synchronized用的锁是存在Java对象头里的.如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头
- java对象头里的Mark-Word里默认存储对象的HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等 

#### 9.synchronized锁的升级与对比
- jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
- 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

#### 10。自旋锁
- 自旋锁:所谓自就是让线程执行一段无意义的循环，防止不会被立即挂起。看持有锁的线程是否会很快释放锁。优点是避免线程切换带来的开销，缺点是：占用了处理器的时间。在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；

#### 11.适应自旋锁
- 适应自旋锁：所谓自适应就意味着自旋的次数不再是固定的。而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多。反之如果自旋很少能成功，那吗在以后获取这个锁时自选次数会减少或者直接忽略掉自旋操作。

#### 12.锁消除和锁粗化
- 锁消除：如果JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。比如StringBuffer的append()方法，Vector的add()方法
- 锁粗化：就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁

#### 13.synchronized的锁升级流程之偏向锁
- 当一个线程访问同步代码块时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程进入和退出同步块时，不需要执行CAS操作来加锁和解锁，只需要简单的测试下对象头的Mark-Word是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获取到锁
- 如果测试失败，则需要在测试下Mark-Word中偏向锁的表示是否设置为1（表示当前是偏向锁）；如果没有设置，则使用CAS竞争；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
- 偏向锁使用了一种等到竞争出现才释放锁的机制，当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁
- 偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）
- 它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否存活，如果线程处于不活动状态，则会将对象头设置成无所状态
- 如果线程仍然活着，拥有偏向锁的线程会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程

#### 14.synchronized的锁升级流程之轻量级锁
- 引入轻量级锁的目的是为了减轻重量级锁使用操作系统的互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁
- 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间,并将对象头中的Mark Word复制到锁记录中(官方称为Displaced Mark Word)
- 然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针
- 如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁
- 轻量级解锁时，会使用原子的CAS操作将Displaced-Mark-Word替换回到对象头。如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁
- 轻量级锁的加锁和释放锁都是使用CAS操作来执行的

#### 14.synchronized的锁升级流程之重量级锁
- 重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。


#### 15.偏向锁,轻量锁，重量级锁的优缺点对比
- 偏向锁： 加锁和解锁不需要额外的消耗，和执行非同步方法只存在纳秒级的差距。缺点是如果线程间存在锁竞争，会带来额外的锁撤销的消耗。适用于只有一个线程访问同步块
- 轻量级锁：竞争的线程不会阻塞，提高了线程的响应速度。缺点是如果始终得不到锁竞争的线程，使用自旋会消耗CPU。适用于追求响应时间，同步块执行速度非常快
- 重量级锁：线程竞争不使用自旋，不会消耗CPU。缺点是线程阻塞，响应时间慢。适用追求吞吐量，同步块执行时间过长。

#### 16.原子操作的实现原理
- 原子操作意为不可被中断的一个或一系列操作
- 处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。
- 总线锁：所谓总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线锁输出此信号时，其它处理器就会被阻塞，该处理器将独占内存。
- 缓存锁：所谓 "缓存锁定“是指内存区域如果被锁定在缓存处理器缓存行中，并且Lock操作期间被锁定,那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内存的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会是缓存行无效。
- java如何实现原子操作： 使用循环CAS和锁的方式实现原子操作

#### 17.CAS实现原子操作的三大问题
- JVM中的CAS是利用处理的cmpxchg（汇编指令，比较并交换操作数）来实现的
- ABA问题（CAS操作时需要先检查值是否变化，但是一个值是A接着被改为B 后面又修改为A，CAS操作就会认为他们没有变化。ABA的解决思路是利用版本号）
- 循环时长开销大（自旋CAS长时间不成功会增大CPU的开销）
- 只能保证一个共享变量的原子操作。解决思路把多个变量合并为一个变量操作。JDK1.5开始提供了AtomicReference保证对象引用之间的原子性，就可以把多个变量放在同一个对象里进行CAS操作

#### 18.线程有哪些状态？
- 新建(NEW)：新创建了一个线程对象。
- 可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。
-  运行(RUNNING)：可运行状态(runnable)的线程获得了cpu时间片（timeslice） ，执行程序代码。
-  阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu使用权，暂时停止运行。阻塞的情况分三种：等待阻塞（wait方法）， 同步阻塞（线程在获取对象的同步锁时）， 其他阻塞（Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时）

#### 19.sleep() 和 wait() 有什么区别？
- sleep()方法是Thread的静态方法，而wait是Object实例方法
- wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用
- wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
-  sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。

#### 20.notify()和 notifyAll()有什么区别？
- notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；由JVM确定唤醒哪个线程，而且不是按优先级
- notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；

#### 21.线程的 run()和 start()有什么区别？
- run()是在主线程中执行方法，和调用普通方法一样；（按顺序执行，同步执行）
- start()方法：是创建了新的线程，在新的线程中执行；（异步执行）
- 启动一个线程，当然要调用strat()

#### 22.创建线程池有哪几种方式？
- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务
- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小
- newCachedThreadPool：创建一个可缓存的线程池。此线程池不会对线程池大小做限制。线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小
- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

#### 23.线程池都有哪些状态？
- RUNNING(运行中)：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。线程池的初始化状态是RUNNING。
- SHUTDOWN(关掉)：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
- STOP(停止):调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 
- tidying：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。
- terminated(终止)：线程池彻底终止，就变成terminated状态。 线程池处在tidying状态时，执行完terminated()之后，就会由 tidying -> terminated。

#### 24.线程池中 submit()和 execute()方法有什么区别？
- 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中


#### 25.在java 程序中怎么保证多线程的运行安全？
- 线程安全在三个方面体现.如果可以保证以下三个方面，那马多线程的运行安全就得到了保证。一般是通过加锁的方式实现，分布式环境下。则要使用分布式锁
- 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作
- 可见性：一个线程对主内存的修改可以及时地被其他线程看到
- 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序

#### 26.什么是死锁？如何避免死锁？
- 线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行,就是死锁
- 按顺序加锁,每个获取锁的时候加上个时限,按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终断线程或回滚操作等。

#### 27.说一下 atomic 的原理？
- 在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类。
- Atomic包下的类是通过CAS操作来实现原子性的。jdk8直接使用了Unsafe的getAndAddInt方法

#### 28.说一下 volatile的实现原理？
- volatile修饰的变量可以禁止指令重排序和保证了内存可见性和单一操作的原子性，类似i++这样的复合操作的原子性保证不了
- 当一个变量被valatile修饰后，表示线程的工作内存是无效的，每次进行运算时都会重新从主内存加载最新的值到工作内存中
- 当一个线程修改共享变量后他会立即被更新到主内存中
- 在JVM底层volatile是采用“内存屏障”来实现的。
- 加入volatile关键字时，会多出一个lock前缀指令。lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。
- volatile经常用于两个两个场景：状态标记两、单列模式中的DCL

#### 29.volataile的内存语义及其实现？
- 如果第一个操作为volatile读，则不管第二个操作是啥，都不能重排序。这个操作确保volatile读之后的操作不会被编译器重排序到volatile读之前；
- 当第二个操作为volatile写是，则不管第一个操作是啥，都不能重排序。这个操作确保volatile写之前的操作不会被编译器重排序到volatile写之后；
- 当第一个操作volatile写，第二操作为volatile读时，不能重排序。



#### 29.说一下happens-before的理解？
- 在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。
- 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法
- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
- happen-before原则是JMM中非常重要的原则，它是判断数据是否存在竞争、线程是否安全的主要依据，保证了多线程环境下的可见性


#### 30.说一下happens-before八种规则？
- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
- volatile变量规则：如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

#### 31.什么是AQS？
- AQS抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制
- AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。
- AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。
- 实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物


## JVM
#### 说一下jvm 的主要组成部分？及其作用？
- JVM基本上由三部分组成：类加载器，执行引擎，运行时数据区
- 类加载器：在JVM启动时以及程序运行时将需要加载的class文件加载到JVM中
- 执行引擎：负责执行class文件中包含的字节码指令，相当于物理机器上的CPU
- 运行时数据区：将划分给Java程序的内存划分成几个区来模拟物理机器上的存储、记录和调度功能


#### 说一下 jvm 运行时数据区？
- 线程私有的：虚拟机栈，本地方法栈，程序计数器
- 线程共享的 方法区，堆
- 程序计数器可以看作是当前线程所执行的字节码行号指示器。通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支,循环,跳转,异常处理,线程恢复等基础功能都需要这个计数器来完成
- 虚拟机栈：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程
- 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
- 方法区主要用于存放已经被虚拟机加载的类信息，如常量，静态变量，即时编译器编译后的代码等。和Java堆一样不需要连续的内存，并且可以动态扩展
- Java 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。堆内存也分为 新生代、老年代。



#### 说一下堆栈的区别？

#### 队列和栈是什么？有什么区别？

#### 什么是双亲委派模型？

#### 说一下类加载的执行过程？

#### 怎么判断对象是否可以被回收？

#### java 中都有哪些引用类型？

#### 说一下 jvm 有哪些垃圾回收算法？

#### 说一下 jvm 有哪些垃圾回收器？

#### 详细介绍一下 CMS 垃圾回收器？

#### 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？

#### 简述分代垃圾回收器是怎么工作的？

#### 说一下 jvm 调优的工具？

#### 常用的 jvm 调优的参数都有哪些？


## Spring
#### 为什么要使用 spring？
- 轻量：Spring 是轻量的，基本的版本大约2MB。
- 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
- 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
- 容器：Spring 包含并管理应用中对象的生命周期和配置。
- MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
- 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
- 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。

#### 我就知道你会说IOC啦，解释一下什么是 ioc？
- IOC就是依赖控制转化，利用JAVA的反射机制，将实例的初始化交给Spring。Spring可以通过配置文件管理实例。

#### 工厂模式也可以管理实例的初始化呀，为什么一定要使用Spring呢？
- 因为IOC是通过反射机制来实现的。当我们的需求出现变动时，工厂模式会需要进行相应的变化。但是IOC的反射机制允许我们不重新编译代码，因为它的对象都是动态生成的。


#### 解释一下什么是 aop？
- aop是面向切面编程，使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。比如权限供职，日志

#### 说一下 spring mvc 运行流程？
- 核心控制器捕获请求、查找Handler、执行Handler、选择ViewResolver,通过ViewResolver渲染视图并返回
- 用户向服务器发送请求，请求被 Spring 前端控制 Servelt DispatcherServlet 捕获(捕获)
- 前端控制器会找到处理器映射器（HandlerMapping），通过HandlerMapping完成url到controller映射的组件
- HandlerMapping有了映射关系，并且找到url对应的处理器，HandlerMapping就会将其处理器（Handler）返回
- DispatcherServlet拿到Handler后，找到HandlerAdapter（处理器适配器），通过它来访问处理器，并执行处理器。
- 处理器会返回一个ModelAndView对象给HandlerAdapter
- 通过HandlerAdapter将ModelAndView对象返回给前端控制器(DispatcherServlet)
- 前端控制器请求视图解析器(ViewResolver)去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)
- 返回视图对象到前端控制器
- DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）
- DispatcherServlet响应用户



#### spring 支持几种 bean 的作用域？
- singleton : bean在每个Spring ioc 容器中只有一个实例。
- prototype：一个bean的定义可以有多个实例。
- request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。
- session：在一个HTTP，Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。
- global-session：在一个全局的HTTP，Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效
- 缺省的Spring bean 的作用域是Singleton.

#### spring 中的 bean 是线程安全的吗？
- Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。
- 但实际上，大部分的Spring-bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。
- 最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。

#### spring 自动装配 bean 有哪些方式？
- no – 缺省情况下，自动配置是通过“ref”属性手动设定，在项目中最常用
- byName – 根据属性名称自动装配。如果一个bean的名称和其他bean属性的名称是一样的，将会自装配它。
- byType – 按数据类型自动装配。如果一个bean的数据类型是用其它bean属性的数据类型，兼容并自动装配它。
- constructor – 在构造函数参数的byType方式。
- autodetect – 如果找到默认的构造函数，使用“自动装配用构造”; 否则，使用“按类型自动装配”


#### spring 事务实现方式有哪些？
- 使用  transactionTemplate,在service中注入模板，通过模板方法控制事物.和业务代码耦合！！！(不采用)
- 通过业务service事务代理,业务方法中采用注入代理类的方式使用.个业务方法都要配置，繁琐，难维护
- 通过切面的方式.简便，跟业务代码解耦，和灵活配置
- 使用注解的方式

#### 说一下 spring 的事务隔离？
- 在Spring中定义了5中不同的事务隔离级别： 
- isolation_default：使用数据库默认的事务隔离级别
- isolation_read_uncommitted：允许读取尚未提交的修改，可能导致脏读、幻读和不可重复读
- isolation_read_committed：允许从已经提交的事务读取，可防止脏读、但幻读，不可重复读仍然有可能发生
- isolation_repeatable_read：对相同字段的多次读取的结果是一致的，除非数据被当前事务自生修改。可防止脏读和不可重复读，但幻读仍有可能发生
- isolation_serializable：完全服从acid隔离原则，确保不发生脏读、不可重复读、和幻读，但执行效率最低。

#### @Autowired 的作用是什么？
- 表示被修饰的类需要注入对象,spring会扫描所有被@Autowired标注的类,然后根据 类型 在ioc容器中找到匹配的类注

#### spring 有哪些主要模块？
- Spring AOP  面相切面编程
- Spring ORM  Hibernate|mybatis|JDO
- Spring Core  提供bean工厂 IOC
- Spring Dao  JDBC支持
- Spring Context  提供了关于UI支持,邮件支持等
- Spring Web 提供了web的一些工具类的支持
- Spring MVC  提供了web mvc , webviews , jsp ,pdf ,export


#### spring mvc 有哪些组件？
- 五大核心组件
- DispatcherServlet　　请求入口
- HandlerMapping　　  请求派发,负责请求和控制器建立一一对应的关系
- Controller　　　　　  处理器
- ModelAndView　　　  封装模型信息和视图信息
- ViewResolver　　　　视图处理器,定位页面
