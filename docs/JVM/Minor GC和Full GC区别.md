### Minor GC和Full GC区别
 **概念：** 
 

- 新生代 `GC（Minor GC）`：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具
备朝生夕灭的特性，所以` Minor GC` 非常频繁，一般回收速度也比较快。
- 老年代 `GC`（Major GC  / Full GC）：指发生在老年代的 GC，出现了 Major GC，经常
会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里
就有直接进行 `Major GC` 的策略选择过程） 。`MajorGC` 的速度一般会比 Minor GC 慢 10
倍以上。


### Minor GC触发机制：
当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC

### Full GC触发机制：
- 当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代，
- 当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载

###  在Java中对象访问是如何进行的？
-  对象访问在Java中无处不在，即时是最简单的访问也会涉及到Java栈，Java堆，方法区这三个最重要的内存区域之间的关系。
```
Object obj=new Object();
```


- 假设这段代码出现在方法体中， 那吗“`Object obj`”这部分的语义将会反应到`Java栈`的本地变量中，
 作为一个`reference`类型数据出现。而“`new Object()`”这部分的语义将会反应到`Java堆`中,形成一块存储了Object类型所有实例数据值的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度是不固定的。
- 另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型，父亲，实现的接口，方法等）的地址消息，这些类型数据则存储在方法区中。


### jvm是怎样判断一个对象是否存活着？
- 是否使用引用计数法？很多判断对象存活的算法是这样的，给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器减1；
- 任何时刻计数器都为0的对象就是不可能再被使用的。客观的来说，引用计数法的实现简单，判定效率也很高，在大部分情况下是一个不错的算法，也有一些著名的案例，列如微软的COM技术，但是，在Java语言中没有选用引用技术发来管理内存，其中最主要的原因是因为它很难解决对象之间的互循环引用问题。

> 摘抄自<<深入理解Java虚拟机>>一书中的原话
- 根搜索算法：Java是使用根搜索算法判断对象是否存活的。
- 这个算法的思路就是通过一系列的名为“GC roots"的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象的GC roots没有任何引用链相连时，则证明此对象是不可用的。如下图所示，对象object5,object6,object7虽然相互关联，但是他们的GC roots是不可达到的，所以它们将会被判定是可回收的对象。

![输入图片说明](https://gitee.com/uploads/images/2018/0703/173354_410e32c9_1478371.png "image.png")


### 在Java中作为GC roots的对象包括以下几种
- 虚拟机栈(栈中的本地变量表)中的引用对象。
- 方法区中的类静态属性引用对象。
- 方法区中的常量引用的对象。
- 本地方法中JNI（即一般说的native方法）的引用的对象。

### Java中的四种引用:
 **强引用：** 

就是指在程序代码中普遍存在的，类似Object obj=new Object()这类的引用，只要强引用还存在，垃圾回收期永远不会回收掉被引用的对象

 **软引用：** 

用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出前，将会把这些对象列进回收范围之内并进行第二次回收，如果这此次回收还是没有足够的内存，才会抛出内存溢出。
 

 **弱引用：** 

用来描述非必须的对象，但是它的强度比软引用更弱一下，被弱引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，只会回收被弱引用关联的对象

 **虚引用：** 

被称为幽灵引用或幻引用，是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其它生存时间构成影响，也无法通过虚引用来取得一个实列。为一个对象设置虚引用的目的就是在对象被回收时收到一个系统通知。


### 回收方法区
- 很多人任务方法区是没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而在方法去进行垃圾收集的性价比一般比较低，在堆中，由其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~96%的空间，而永久代的垃圾收集效率远低于此。
- 永久代的垃圾主要回收两部分内容：废弃常量和无用的类。
- 回收废弃常量于回收`Java堆`中的对象非常相似。以常量池中字面量的回收为列，假如一个字符串“`abc`"已经进入常量池中，但是当前系统没有任何一个String对象叫做”`abc`"的，换句话就是没有任何Sting对象引用常量池中的"abc",也没有其它地方引用了这个字面变量，如果这时候发生内存回收，而且必要的话，这个“`abc`"常量就会被系统请出常量池，常量池中的其它类，接口，方法，字段的符号引用也与此类似。

![输入图片说明](https://gitee.com/uploads/images/2018/0703/173826_78dcbdc8_1478371.png "image.png")


### 垃圾收集算法
 **标记-清除算法：**
- 算法分为标记和清除两个阶段。首先先标记所有要被回收的对象，标记完成后再统一清除被标记的对象。

 **主要缺点有两个，** 
- 一是效率问题，标记和清除的过程效率都不高。二是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多,可能会导致，当程序在以后的运行过程中需要分配较大的对象时无法找到足够的连续内存，而不得不提前出发另一次垃圾收集动作

 **复制算法：** 
- 为了解决效率问题，一种复制收集的算法出现了。它将可用内存按容量划分为大小相等的两块，每次只用其中的一块。当这一块内存用完，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中一块进行内存回收，内存分配时也就不用内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半未免太高了一点。

 **标记-整理算法** 
- 复制手机算法在对象存活率较高的时要执行多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中对象都100%存货的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另一种 标记-整理的算法，标记过程仍然与 标记-清楚算法一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

 **分代收集算法** 
- 根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理算法来进行回收

